% ---------------------------------------------------
%
% Proyecto de Final de Carrera: 
% Author: Juan José Fumero Alfonso <alu3513@etsii.ull.es>
% Introducción
% Fichero: Prologo.tex
%
% ----------------------------------------------------

\chapter*{Introducción}
\addcontentsline{toc}{chapter}{Introducción} 

En este documento se recoge el trabajo de investigación y desarrollo realizado por el 
autor para completar su \acf{PFC}, finalizando con el mismo
los estudios en Ingeniería en Informática cursados en la \ETSII{} de la \ULL{}.

Este \ac{PFC} se ha desarrollado en torno al proyecto de investigación \acf{accULL}.
\accULL{} es una implementación de código abierto realizada en la \ULL{} de un framework 
de compilación para arquitecturas heterogéneas bajo el estándar \ac{OpenACC} 
\cite{URL::OpenACC}. El framework 
tiene dos componentes principales. Estos son un compilador \ac{StS} 
denominado \yacf{} \cite{Reyes:2013:YAC}, y un entorno de ejecución para el 
código generado, conocido por 
\Frangollo{} \cite{Reyes:2013:FRT}, en forma de librería de soporte al ejecutable.

Los objetivos abordados en el \ac{PFC} se han centrado en dos frentes. Por un lado,
lo que atañe a la investigación
en mejoras de rendimiento mediante optimizaciones de bucles, con especial énfasis en
\tiling{} por su relevancia en las arquitecturas vectoriales, así como las arquitecturas
matriciales propias de las \gpu{}s.
Y por otra parte, todo el desarrollo,
depuración, y puesta a punto de las últimas distribuciones del framework \accULL{}
(en adelante, el compilador). Trabajo con el que ha sido posible publicar la versión
0.3alpha de dicho compilador.

En los Capítulos que componen esta memoria se intenta sintetizar el trabajo realizado 
mediante la aplicación de las destrezas y habilidades adquiridas a lo largo de la
vida del \ac{PFC}, así como durante los años de discencia en la \ETSII{} de la \ULL{}.

Hasta no hace mucho tiempo, la aproximación más extendida y madura para programar 
arquitecturas heterogéneas de propósito general que incorporaran \GPU{}s era
\CUDA{} \cite{Nickolls:2008:SPP}. Se trata en esencia de un entorno de programación en C 
con un pequeño conjunto de 
extensiones. \CUDA{} permite al programador reescribir sus códigos para explotar 
paralelismo en \GPU{}s. A pesar de la relativa simplicidad del desarrollo de aplicaciones
en este entorno, es difícil alcanzar las máximas prestaciones debido a los enormes
esfuerzos necesarios en codificación, depuración y optimización. 
Si a esto añadimos la falta de portabilidad, que sólo permite hacer uso de \GPU{}s de 
\NVIDIA{},
queda manifiesta la insuficiencia de esta aproximación. 

\OpenCL{} \cite{OpenCL:2009:TOS} 
es un estándar que representa un esfuerzo para crear 
una interfaz común de programación para dispositivos heterogéneos. Es un estándar 
abierto que sigue una estrategia similar a \CUDA{}, y con el apoyo de distintos
fabricantes de dispositivos ha comenzado a generalizarse su aceptación.

El nuevo estándar para computación heterogénea \OpenACC{} \cite{URL::OpenACC}, se presentó
por primera vez en la conferencia SuperComputing'2011.
Este estándar representa un claro impulso destinado a facilitar la implementación de 
programas que 
exploten la capacidad de cómputo de los dispositivos aceleradores, y evita la falta de 
portabilidad inherente a adoptar un nuevo modelo de programación presentes en
los estándares heterogéneos existentes con anterioridad. Tratando de imitar el éxito de 
OpenMP en las arquitecturas \CPU{} con memoria compartida, 
la API de \OpenACC{} facilita al programador la anotación de códigos secuenciales 
con directivas de compilación. Estas anotaciones
indicarán aquellas regiones susceptibles de ser ejecutadas en un dispositivo de
aceleración, como puede ser una \GPU{} o las unidades \SIMD{} de una \CPU{}. 

La simplicidad del modelo, su facilidad de adopción por parte de usuarios no expertos, así 
como el respaldo de las empresas que avalan el 
estándar (\NVIDIA{}, \Cray{}, \PGI{} y \CAPS{}) han fomentado que la última revisión del 
popular estándar \OpenMP{} \cite{URL::OpenMP} incluya soporte para aceleradores hardware.
Claros precursores de \OpenACC{} han sido tanto el \PGI{} Accelerator Model 
\cite{Wolfe:2010:IPA} que también suministra un modelo de programación de 
alto nivel para aceleradores hardware, como el entorno HMPP 
\cite{Bodin:2009:HMP} de \CAPS{}. 
Tanto \PGI{} como \CAPS{} son promotores de \OpenACC{} y llevan varios meses 
comercializando compiladores con soporte para el estándar. Una clara muestra de la 
importancia que está cobrando la programación basada en directivas para \gpu{} es el
creciente interés en la comunidad investigadora \cite{Lee:2012:EED}.

Esta Memoria del \ac{PFC} está estructurada en torno a siete Capítulos, 
cuyos contenidos se describen brevemente a continuación:

El Capítulo \ref{chap:motivation} sitúa al lector en el contexto de la Computación de 
Altas Prestaciones, y más concretamente en la creciente tendencia a explotar las llamadas 
arquitecturas heterogéneas, apoyadas en dispositivos aceleradores masivamente paralelos. 
El Capítulo continúa con un breve recorrido por la historia de la investigación en la que 
se enmarca este \ac{PFC} y termina con una nota sobre la razón de la importancia de 
abordar las optimizaciones de bucles.

En el segundo Capítulo se definen los objetivos que se han marcado a la hora de realizar este \ac{PFC}, resaltando los puntos más destacables de las tareas propuestas. 

El Capítulo \ref{chap:polytopes} introduce el modelo poliédrico como herramienta 
matemática para la asistencia en las transformaciones de código,
y se describe el framework \pocc{}, que recopila una serie de herramientas para las 
optimizaciones de bucles basadas en politopos. Este Capítulo es el fruto de la 
investigación llevada a cabo durante la vida del \ac{PFC}, en aquellos aspectos  relacionados con el estado del arte de las optimizaciones de bucles.

El Capítulo \ref{chap:yacf} está dedicado al framework de compilación \acf{StS} \yacf{}. 
En él se describen los módulos de los que se compone \yacf{}, en el contexto 
de la programación heterogénea basada en directivas. Así mismo, es una guía de referencia
de la infraestructura software puesta a disposición de los desarrolladores.

En el Capítulo \ref{chap:optGPGPU} se describe el trabajo realizado en el compilador para 
llevar a cabo la planificación de instrucciones con paralelismo a nivel de \thread{}s, 
siguiendo los criterios investigados en el Capítulo \ref{chap:polytopes}. Haciendo uso 
además, de lo estudiado en el Capítulo \ref{chap:yacf}.

El Capítulo \ref{chap:resultados} presenta resultados computacionales para un 
conjunto de aplicaciones usando el compilador mediante la última versión del framework 
\accULL{}, compuesto de \yacf{} como compilador \sts{} y \texttt{Frangollo} como librería 
de apoyo a la ejecución. 
Los códigos presentados en este último Capítulo como los \rodinia{}, han sido anotados a 
partir de una versión secuencial, o aprovechando la investigación más reciente en este 
sector, como es el caso de los códigos del \benchmark{} \OpenACC{} del \epcc{} 
\cite{URL::ACCepccB}.

Se concluye esta memoria con un Capítulo \ref{chap:conclusiones} de conclusiones en el que 
se plantean los logros alcanzados en la vida del \ac{PFC}, y se muestran algunas de las 
líneas abiertas pendientes de abordar.

%En los apéndices de esta memoria se incluyen algunos Listados de código que han sido 
%considerados relevantes para comprender algunos aspectos concretos del desarrollo.
%Por otra parte,
Todo el código fuente que se presentan en esta memoria 
referidos al proyecto \accULL{} está disponibles en la web del \gcap{} 
\cite{Web:gcap}. \accULL{} es público y de libre distribución bajo licencia 
GPL. 
